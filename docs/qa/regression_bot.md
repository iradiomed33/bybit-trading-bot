# Регресс‑чеклист для торгового бота (Bybit)

Файл: `docs/qa/regression_bot.md`  
Назначение: прогон регресса после реализации задач **A1 → VAL‑002** (исключая EPIC G).  
Фокус: “бот реально торгует” — сигнал → фильтры → риск → ордер → позиция → выход → безопасность → отчётность.

---

## 0) Область покрытия

### Включено
- EPIC A: A1–A4 (MTF, индикаторы, фильтры качества)
- EPIC B: B1–B3 (live‑ветка, подпись, правила инструмента)
- EPIC C: C1–C3 (позиция: state, SL/TP, flip/add/ignore)
- EPIC D: D1–D3 (kill switch, лимиты, vol‑scaling)
- EPIC E: E1–E2 (paper/backtest)
- EPIC F: F1 (структурированные причины)
- EPIC S: STR‑001..STR‑007 (улучшение стратегий)
- EPIC M: META‑001..META‑002 (скоринг MTF, режимы)
- EPIC X: EXE‑001..EXE‑003 (maker/taker, partial fills, slippage model)
- EPIC R: RISK‑001..RISK‑002 (risk per trade, circuit breaker)
- EPIC V: VAL‑001..VAL‑002 (бэктест/форвард, sweep)

### Исключено
- EPIC G: безопасность API/панели (по запросу пользователя)

---

## 1) Предусловия и тестовые окружения

### 1.1 Окружения
- **TESTNET** (обязателен для e2e live‑исполнения)
- **PAPER** (симулятор сделок)
- **BACKTEST** (исторический прогон)

### 1.2 Инструмент/символы
- Базовый символ: `BTCUSDT` (или тот, который у вас “по умолчанию”)
- Доп. символ для проверки общности: `ETHUSDT`

### 1.3 Настройки/конфиги (минимум)
- Включаемые флаги:
  - `use_mtf = true/false`
  - `mode = paper/live/backtest`
  - `breakout_entry = instant/retest`
  - `entry_mode = confirm_close/limit_retest`
- Риск:
  - `risk_pct` (например 1%)
  - `max_leverage`, `max_notional`, `daily_loss_limit`
- Комиссии:
  - `fee_maker`, `fee_taker`
- Slippage:
  - `slippage_bps` (и/или модель от ATR/volume)

### 1.4 Наблюдаемость
- Логи уровня INFO/DEBUG доступны в консоли и в файле.
- БД (если используется) доступна для проверки сделок/состояния.

---

## 2) Артефакты регресса (что сохраняем)
- Логи прогона (путь/архив)
- Скрин/выписка:
  - открытый ордер (TESTNET)
  - отмена ордера
  - позиция до/после
- Экспорт/дамп таблиц (если есть): trades, positions, signals, risk_events
- Отчёты:
  - paper equity curve + метрики
  - backtest отчёт + out‑of‑sample

---

## 3) Быстрый “Smoke” перед полным регрессом (15–30 минут)

- [ ] SMK‑01: Бот стартует без исключений, конфиг читается, видны версии/параметры запуска.
- [ ] SMK‑02: Market data грузится (OHLCV не пустой), последняя свеча свежая.
- [ ] SMK‑03: FeaturePipeline считает ключевые фичи без NaN на хвосте (`atr`, `rsi`, `adx`, BB width и т.п.).
- [ ] SMK‑04: В режиме `paper` генерируются и применяются сделки (не “просто лог”).
- [ ] SMK‑05: В TESTNET приватный вызов работает (balance/positions/создание ордера).
- [ ] SMK‑06: Kill switch можно активировать вручную и он реально закрывает риск.

Если smoke не проходит — **полный регресс не начинать**.

---

## 4) Регресс‑чеклисты по задачам

Ниже чеклисты сгруппированы по эпикам/задачам.  
Формат: **ID → шаги → ожидаемо → артефакты**.

---

# EPIC A — Сигналы/данные/индикаторы

## A1 — MTF: кэш таймфреймов наполняется и MTF не “убивает” торговлю

### REG‑A1‑01: Загрузка свечей для всех MTF‑TF
- [ ] Запустить бота с `use_mtf=true`
- [ ] Проверить лог: загрузка свечей для TF (напр. 15m/1h/4h) с количеством `N > 0`
- [ ] Проверить `timeframe_cache` (через debug endpoint/лог/дамп): ключи TF присутствуют

**Ожидаемо:** для каждого TF есть DataFrame/массив свечей, хвост актуален.  
**Артефакт:** лог‑фрагмент “Fetched candles for …”.

### REG‑A1‑02: MTF принимает сигналы по скорингу (если внедрён META‑001)
- [ ] Смоделировать период, где LTF даёт сигнал (можно через backtest или фикстуры)
- [ ] Проверить, что `mtf_score` рассчитывается и влияет на решение

**Ожидаемо:** нет “вечного reject” из‑за MTF; в логах `mtf_score`, `threshold`, `decision`.  
**Артефакт:** запись решения meta.

### REG‑A1‑03: Поведение при `use_mtf=false`
- [ ] Запустить с `use_mtf=false`
- [ ] Убедиться, что `timeframe_cache` не требуется для торговли
- [ ] Сигналы проходят без MTF‑причин

**Ожидаемо:** meta‑слой не отклоняет из‑за отсутствия TF.  
**Артефакт:** лог decision без MTF.

---

## A2 — Единые имена индикаторов (ADX/RSI и др.)

### REG‑A2‑01: Каноничные колонки присутствуют
- [ ] Прогнать `FeaturePipeline` на 300+ свечах
- [ ] Проверить наличие колонок: `rsi`, `adx`(или `ADX_14`), `atr`, BB width и т.п.

**Ожидаемо:** колонки есть, типы числовые, хвост без NaN.  
**Артефакт:** дамп `df.tail()`/лог перечисления фич.

### REG‑A2‑02: RegimeSwitcher читает те же имена
- [ ] Прогнать `RegimeSwitcher.detect_regime()` на тестовых данных (trend/range/high_vol)
- [ ] Убедиться, что режим меняется ожидаемо (не “вечно range” из‑за ADX=0)

**Ожидаемо:** корректная классификация режимов.  
**Артефакт:** лог `regime=...` + значения индикаторов.

### REG‑A2‑03: Стратегии читают те же имена
- [ ] Запустить стратегии на том же df
- [ ] Проверить, что они не обращаются к несуществующим колонкам

**Ожидаемо:** нет дефолтов “на глаз” из‑за missing columns.  
**Артефакт:** отсутствие warning “missing …”.

---

## A3 — RSI реально считается и используется

### REG‑A3‑01: RSI диапазон 0..100 и без NaN на хвосте
- [ ] На живых свечах и на синтетическом тренде посчитать RSI
- [ ] Проверить min/max и NaN на последних 50 барах

**Ожидаемо:** `0 ≤ rsi ≤ 100`, на хвосте NaN отсутствуют.  
**Артефакт:** вывод статистики.

### REG‑A3‑02: Mean Reversion перестаёт быть “всегда neutral”
- [ ] Подать данные range‑режима с явной перекупленностью/перепроданностью
- [ ] Проверить, что MR выдаёт сигнал и причины (rsi/отклонение)

**Ожидаемо:** MR генерирует сделки в допустимых режимах.  
**Артефакт:** запись signal с reasons.

---

## A4 — Фильтры качества (vol/volume/структура)

### REG‑A4‑01: Volume filter блокирует вход при низком объёме
- [ ] Подать набор свечей с низким volume (ниже порога)
- [ ] Сгенерировать сигнал стратегии

**Ожидаемо:** сделка отклонена, причина `volume_low`.  
**Артефакт:** decision log.

### REG‑A4‑02: Volatility filter блокирует вход без expansion
- [ ] Сценарий “пробой без расширения волы”
- [ ] Проверить reject `vol_not_expanding`

**Ожидаемо:** breakout без expansion не торгует.  
**Артефакт:** признаки squeeze/expansion в логах.

---

# EPIC B — Live‑исполнение и Bybit‑авторизация

## B1 — Live‑ветка не падает (интерфейсы согласованы)

### REG‑B1‑01: Live‑ветка проходит до place_order без исключений (mock)
- [ ] Unit/integration test с мокнутыми `AccountClient`, `OrderClient`
- [ ] Подать buy/sell signal

**Ожидаемо:** нет AttributeError/TypeError, формируется корректный ордер.  
**Артефакт:** отчёт тестов.

### REG‑B1‑02: Live‑ветка на TESTNET с “микро‑ордером”
- [ ] Запуск live на тестнете
- [ ] Вход малым qty (minOrderQty)

**Ожидаемо:** ордер accepted.  
**Артефакт:** ответ API (`retCode=0`) + запись в БД/лог.

---

## B2 — Подпись/авторизация (GET/POST)

### REG‑B2‑01: Приватный GET работает стабильно
- [ ] 20 последовательных вызовов `get_wallet_balance`/`get_positions`
- [ ] Отсутствие ошибок timestamp/signature

**Ожидаемо:** 0 ошибок auth.  
**Артефакт:** логи/счётчик ошибок.

### REG‑B2‑02: Приватный POST place_order проходит (TESTNET)
- [ ] Поставить лимитный ордер (post‑only, если доступно)
- [ ] Проверить, что подпись корректна

**Ожидаемо:** `retCode=0`, ордер виден в openOrders.  
**Артефакт:** JSON‑ответ + скрин/лог openOrders.

### REG‑B2‑03: Отмена ордера (POST) работает
- [ ] Cancel по orderId
- [ ] Проверить статус

**Ожидаемо:** ордер исчез из openOrders, нет signature errors.  
**Артефакт:** логи cancel.

---

## B3 — Правила инструмента (tick/step/minQty/minNotional)

### REG‑B3‑01: Округление price по tickSize
- [ ] Передать price с “лишними” знаками
- [ ] Проверить нормализацию в `normalize_order()`

**Ожидаемо:** price округлён строго по tickSize.  
**Артефакт:** лог “raw→normalized”.

### REG‑B3‑02: Округление qty по qtyStep + minQty/minNotional
- [ ] Передать qty ниже minQty и notional ниже minNotional
- [ ] Проверить reject/автокоррекцию (как задумано)

**Ожидаемо:** либо корректировка до минимума, либо reject с причиной `min_qty/min_notional`.  
**Артефакт:** decision.

### REG‑B3‑03: Ордер не отклоняется биржей по “invalid qty/price”
- [ ] 10 ордеров на разных ценах/qty в допустимых диапазонах (TESTNET)
- [ ] Убедиться, что биржа не возвращает invalid params

**Ожидаемо:** 0 отказов по шагам/минималкам.  
**Артефакт:** статистика ответов.

---

# EPIC C — Позиция и сопровождение

## C1 — State позиции + reconcile с биржей

### REG‑C1‑01: Открытие позиции → запись state
- [ ] Открыть позицию (TESTNET или paper)
- [ ] Проверить запись: side/qty/entry/orderId/strategy_id/ts

**Ожидаемо:** state сохранён и доступен для следующего цикла.  
**Артефакт:** запись в БД/лог.

### REG‑C1‑02: Reconcile: ручное закрытие на бирже
- [ ] Открыть позицию
- [ ] Закрыть вручную в терминале Bybit (TESTNET)
- [ ] Дать боту 1–2 цикла

**Ожидаемо:** бот обнаруживает закрытие, сбрасывает state, логирует событие.  
**Артефакт:** лог reconcile.

### REG‑C1‑03: Partial fills корректно отражаются в state
- [ ] Создать условия для partial fill (лимитка рядом со спредом, малый объём)
- [ ] Проверить обновление qty/avgPrice

**Ожидаемо:** state совпадает с биржей после заполнений.  
**Артефакт:** сравнение state vs API.

---

## C2 — SL/TP reduceOnly или виртуальная логика

### REG‑C2‑01: При входе выставляются SL/TP (если биржевые)
- [ ] Открыть позицию
- [ ] Проверить наличие SL/TP параметров/ордеров

**Ожидаемо:** стоп/тейк существуют, reduceOnly=true.  
**Артефакт:** openOrders/позиция.

### REG‑C2‑02: Виртуальные SL/TP (если выбран виртуальный подход)
- [ ] Открыть позицию
- [ ] Смоделировать достижение стоп‑уровня в paper/backtest
- [ ] Проверить, что создаётся close‑ордер и позиция закрывается

**Ожидаемо:** закрытие по триггеру + корректный PnL/комиссии.  
**Артефакт:** trade record.

### REG‑C2‑03: Stop distance привязан к ATR (vol‑based)
- [ ] Сравнить сделки в низкой и высокой воле
- [ ] Проверить stop_distance и qty

**Ожидаемо:** на высокой воле stop шире и qty меньше (при фикс risk_usd).  
**Артефакт:** лог risk calc.

---

## C3 — Flip/Add/Ignore поведение

### REG‑C3‑01: Ignore при наличии позиции
- [ ] Открыть long
- [ ] Подать повторный long signal
- [ ] Проверить отсутствие дубль‑входа

**Ожидаемо:** no‑op с причиной `position_exists`.  
**Артефакт:** лог.

### REG‑C3‑02: Add (пирамидинг) по правилам (если включено)
- [ ] Включить `allow_add=true`
- [ ] Подать условия add
- [ ] Проверить увеличение позиции в пределах лимитов

**Ожидаемо:** add происходит только при выполнении правил и не превышает max exposure.  
**Артефакт:** состояние позиции.

### REG‑C3‑03: Flip (если разрешено)
- [ ] Иметь long
- [ ] Подать sell signal, удовлетворяющий flip‑правилам
- [ ] Проверить последовательность: close long → open short

**Ожидаемо:** нет “перекрытия” (short поверх long без закрытия), корректный reduceOnly на закрытии.  
**Артефакт:** цепочка ордеров.

---

# EPIC D — Risk & Safety

## D1 — Kill switch реально закрывает риск

### REG‑D1‑01: Kill switch отменяет все ордера
- [ ] Создать 1–3 открытых ордера (TESTNET)
- [ ] Активировать kill switch

**Ожидаемо:** все ордера отменены, openOrders пуст.  
**Артефакт:** API openOrders до/после.

### REG‑D1‑02: Kill switch закрывает позицию
- [ ] Открыть позицию
- [ ] Активировать kill switch

**Ожидаемо:** позиция закрыта (reduceOnly close), state сброшен, бот “halted”.  
**Артефакт:** positions до/после.

### REG‑D1‑03: Halted режим — бот не торгует
- [ ] После kill switch подать сигналы
- [ ] Проверить, что ордера не отправляются

**Ожидаемо:** решения = reject, причина `halted`.  
**Артефакт:** логи.

---

## D2 — Лимиты (leverage/notional/daily loss/drawdown)

### REG‑D2‑01: Max leverage enforced
- [ ] Задать `max_leverage` ниже требуемого стратегии
- [ ] Сгенерировать сигнал

**Ожидаемо:** reject с причиной `max_leverage`.  
**Артефакт:** risk decision.

### REG‑D2‑02: Max notional/exposure enforced
- [ ] Поставить низкий `max_notional`
- [ ] Сгенерировать сигнал с большим qty

**Ожидаемо:** qty ограничен или trade отвергнут с `max_notional`.  
**Артефакт:** расчет qty.

### REG‑D2‑03: Daily loss limit → kill switch
- [ ] В paper/backtest смоделировать серию убытков до лимита
- [ ] Проверить триггер

**Ожидаемо:** после достижения лимита — STOP/kill.  
**Артефакт:** запись risk_event.

---

## D3 — Volatility scaling для размера позиции

### REG‑D3‑01: При одинаковом equity риск в USD стабилен
- [ ] Ввести два периода: low ATR и high ATR
- [ ] Сравнить `risk_usd` и `qty`

**Ожидаемо:** `risk_usd` примерно одинаков, `qty` уменьшается на high ATR.  
**Артефакт:** лог.

---

# EPIC E — Paper / Backtest

## E1 — Paper режим = симуляция сделок

### REG‑E1‑01: Paper открывает/закрывает позиции и считает PnL
- [ ] Запустить paper на 1–3 дня данных
- [ ] Проверить trades: entry/exit, комиссии, slippage, PnL

**Ожидаемо:** есть сделки, equity curve меняется, комиссия учитывается.  
**Артефакт:** отчёт paper.

### REG‑E1‑02: Stop/Take работают в paper
- [ ] Найти сделку, где цена достигает SL/TP
- [ ] Проверить exit_reason

**Ожидаемо:** exit_reason = `stop_loss`/`take_profit`/`time_stop`.  
**Артефакт:** запись сделки.

---

## E2 — Backtest runner + out‑of‑sample

### REG‑E2‑01: Backtest запускается и генерирует отчёт
- [ ] Запуск backtest на историческом периоде
- [ ] Проверка: отчёт с метриками PF/DD/expectancy/trades

**Ожидаемо:** отчёт формируется без исключений.  
**Артефакт:** файл/вывод отчёта.

### REG‑E2‑02: Out‑of‑sample разделение реально работает
- [ ] Указать train/test по времени
- [ ] Проверить отдельные метрики по каждому периоду

**Ожидаемо:** две секции отчёта, параметры не “подглядывают” в тест.  
**Артефакт:** отчёт.

---

# EPIC F — Наблюдаемость (структурированные причины)

## F1 — Единый формат причин/значений

### REG‑F1‑01: Любое решение содержит signal/confidence/reasons/values
- [ ] Сгенерировать: accept, reject по фильтру, reject по риску
- [ ] Проверить структуру логов/объекта

**Ожидаемо:** одинаковый контракт, причины читаемы.  
**Артефакт:** 3 примера лог‑записей.

---

# EPIC S — Улучшение стратегий

## STR‑001 — ATR‑стопы и vol‑scaling (проверка)

### REG‑STR‑001: Каждая стратегия возвращает stop/take и они валидны
- [ ] Для каждой стратегии: сгенерировать сделку на тестовых данных
- [ ] Проверить: stop/take определены, stop_distance > 0, уровни логичны относительно side

**Ожидаемо:** у long: stop < entry < take (если take есть), у short наоборот.  
**Артефакт:** вывод параметров сделки.

---

## STR‑002 — Фильтр экстремальных свечей/хвостов

### REG‑STR‑002: “Ликвидационная свеча” → cooldown
- [ ] Сконструировать свечу с range > k*ATR или большим wick_ratio
- [ ] Проверить, что вход запрещён N баров

**Ожидаемо:** reject + затем N баров no‑trade (если сигналы есть).  
**Артефакт:** лог cooldown window.

---

## STR‑003 — Подтверждение входа (confirm/limit retest)

### REG‑STR‑003‑A: confirm_close требует подтверждения
- [ ] Подать сценарий “касание уровня без подтверждения”
- [ ] Убедиться, что входа нет
- [ ] Затем дать подтверждающую свечу → вход появляется

**Ожидаемо:** вход только после подтверждения.  
**Артефакт:** лог reasons.

### REG‑STR‑003‑B: limit_retest ставит лимитку и TTL работает
- [ ] Сигнал → лимитка выставлена
- [ ] Если не заполнилась до TTL → отмена

**Ожидаемо:** нет “висящих” ордеров дольше TTL.  
**Артефакт:** cancel по TTL.

---

## STR‑004 — MR только в range

### REG‑STR‑004: MR в тренде не торгует
- [ ] Подать трендовый набор (high ADX / растущий ATR)
- [ ] Проверить отсутствие сделок MR

**Ожидаемо:** reject по режиму (`regime != range`).  
**Артефакт:** лог regime.

---

## STR‑005 — MR time‑stop / аварийный выход

### REG‑STR‑005: Time stop закрывает позицию
- [ ] Открыть MR позицию в paper/backtest
- [ ] Смоделировать отсутствие возврата к mean
- [ ] Проверить закрытие по `max_hold_bars`

**Ожидаемо:** exit_reason `time_stop`.  
**Артефакт:** запись trade.

---

## STR‑006 — Breakout squeeze→expansion + volume

### REG‑STR‑006: Без squeeze/expansion/volume входа нет
- [ ] 3 сценария: нет squeeze, нет expansion, нет volume
- [ ] Проверить reject с правильной причиной

**Ожидаемо:** отказ с `squeeze_not_ok`/`expansion_not_ok`/`volume_low`.  
**Артефакт:** лог.

---

## STR‑007 — Breakout retest‑entry (анти “вход на пике”)

### REG‑STR‑007: Ретест обязателен и TTL ожидания работает
- [ ] Пробой → ожидание ретеста
- [ ] Ретест не случился до TTL → сигнал отменён
- [ ] В альтернативе: ретест случился → вход

**Ожидаемо:** входы только по ретесту (в режиме retest), TTL соблюдается.  
**Артефакт:** лог ожидания.

---

# EPIC M — Meta / Regime

## META‑001 — MTF скоринг вместо жёсткого запрета

### REG‑META‑001: Сигнал не “умирает”, а получает скоринг
- [ ] Сценарий: LTF сигнал есть, HTF нейтрален
- [ ] Проверить: score средний, решение зависит от threshold (config)

**Ожидаемо:** при пороге ниже — accept, выше — reject, причины прозрачны.  
**Артефакт:** `mtf_score` в логах.

---

## META‑002 — Расширенный regime switch (trend/range/high_vol_event)

### REG‑META‑002‑01: Режим high_vol_event
- [ ] Подать данные с резким ростом ATR/BB width
- [ ] Проверить режим `high_vol_event` и включение cooldown/снижения риска

**Ожидаемо:** торговля ограничена, риск снижен.  
**Артефакт:** лог режима + risk adjustment.

### REG‑META‑002‑02: Trend vs Range различаются устойчиво
- [ ] Подать трендовый и флэтовый наборы
- [ ] Проверить корректные режимы

**Ожидаемо:** режимы не “прыгают” без причины.  
**Артефакт:** лог с метриками режима.

---

# EPIC X — Execution (maker/taker, partial fills, slippage)

## EXE‑001 — Maker/Taker политика

### REG‑EXE‑001: Стратегии выбирают корректный order type
- [ ] Для trend pullback проверить: лимитка (maker) там, где “retest/level”
- [ ] Для breakout instant проверить: IOC/market (taker) при необходимости

**Ожидаемо:** order_type соответствует настройке стратегии.  
**Артефакт:** лог/ордер.

---

## EXE‑002 — Partial fills + reduceOnly

### REG‑EXE‑002‑01: Partial fill обновляет state, нет рассинхрона
- [ ] Создать partial fill на тестнете
- [ ] Проверить state после каждого fill

**Ожидаемо:** qty/avgPrice корректны.  
**Артефакт:** сравнение с API.

### REG‑EXE‑002‑02: Любое закрытие позиции — reduceOnly
- [ ] Любой выход (SL/TP/time/flip/kill) проверить на reduceOnly

**Ожидаемо:** reduceOnly=true на close‑ордерах.  
**Артефакт:** параметры ордера.

---

## EXE‑003 — Slippage model в paper/backtest

### REG‑EXE‑003: Slippage влияет на PnL
- [ ] Прогнать один и тот же период с `slippage_bps=0` и `>0`
- [ ] Сравнить PF/PNL

**Ожидаемо:** при slippage>0 метрики ухудшаются (в разумных пределах).  
**Артефакт:** два отчёта.

---

# EPIC R — Risk (risk per trade, circuit breaker)

## RISK‑001 — Risk per trade через stop_distance + caps

### REG‑RISK‑001‑01: Risk_usd соответствует конфигу
- [ ] Выставить `risk_pct`
- [ ] Сгенерировать сделку
- [ ] Проверить `risk_usd ≈ equity*risk_pct`

**Ожидаемо:** отклонение только из‑за округления/минималок.  
**Артефакт:** лог calc.

### REG‑RISK‑001‑02: Caps блокируют превышение
- [ ] Снизить `max_notional` и `max_exposure`
- [ ] Проверить reject/ограничение qty

**Ожидаемо:** trade не превышает caps.  
**Артефакт:** risk decision.

---

## RISK‑002 — Circuit breaker по воле и серии убытков

### REG‑RISK‑002‑01: Volatility breaker
- [ ] Смоделировать candle_range/ATR spike
- [ ] Проверить STOP на N минут/баров

**Ожидаемо:** no trade в период breaker, причина `vol_breaker`.  
**Артефакт:** risk_event.

### REG‑RISK‑002‑02: Loss streak breaker
- [ ] В paper/backtest добиться N убыточных сделок подряд
- [ ] Проверить STOP/kill

**Ожидаемо:** после N — остановка/kill.  
**Артефакт:** risk_event + halted.

---

# EPIC V — Валидация edge (не “на глаз”)

## VAL‑001 — Единый пайплайн для backtest/forward/live

### REG‑VAL‑001‑01: Один и тот же сигнал на одинаковых данных
- [ ] Взять фиксированный датасет (свечи)
- [ ] Прогнать: backtest и paper (и, если возможно, “dry‑run live” без ордеров)
- [ ] Сравнить: количество и направление сигналов (допуская небольшие расхождения из‑за fill‑модели)

**Ожидаемо:** сигналы/режимы совпадают; различия только в исполнении.  
**Артефакт:** сравнительная таблица/лог.

### REG‑VAL‑001‑02: Метрики отчёта присутствуют и корректны
- [ ] Проверить наличие: trade count, PF, max DD, expectancy/trade, exposure, fee impact

**Ожидаемо:** все метрики считаются, нет деления на ноль/NaN.  
**Артефакт:** отчёт.

---

## VAL‑002 — Parameter sweep + устойчивость (анти переоптимизация)

### REG‑VAL‑002‑01: Sweep запускается и сохраняет результаты
- [ ] Задать сетку параметров
- [ ] Прогнать sweep

**Ожидаемо:** результаты сохранены (CSV/JSON/БД), нет падений на отдельных конфигурациях.  
**Артефакт:** файл результатов.

### REG‑VAL‑002‑02: Отбор по устойчивости между периодами
- [ ] Использовать минимум 2 периода (до/после) или walk‑forward
- [ ] Проверить, что “лучшие” выбираются по стабильности, а не по одному интервалу

**Ожидаемо:** отчёт показывает топ‑конфиги + стабильность (variance/consistency).  
**Артефакт:** отчёт устойчивости.

---

## 5) Критерии прохождения регресса (Release Gate)

Релиз “готов” только если:
- [ ] Все тесты **P0** пройдены (A1–A3, B1–B3, C1–C2, D1–D2, E1, F1, STR‑001/002/004/006, EXE‑001/002, RISK‑001/002, VAL‑001)
- [ ] На TESTNET выполнен полный цикл: **вход → сопровождение → выход → запись результатов**
- [ ] Kill switch гарантированно закрывает риск
- [ ] Paper/backtest дают отчёты с учётом комиссий и slippage
- [ ] Нет критических ошибок в логах (Exception/Traceback)

---

## 6) Приложение: шаблон отчёта прогона

Заполнить после регресса:
- Версия/коммит:
- Окружение: TESTNET/PAPER/BACKTEST
- Символы/TF:
- Конфиги риска:
- Итог: PASS/FAIL
- Список найденных дефектов:
  - BUG‑1:
  - BUG‑2:
- Ссылки на артефакты (логи/отчёты/дампы):

